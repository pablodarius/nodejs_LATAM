"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const jsdom = require("jsdom");
const rxjs = require("rxjs");
const tough = require("tough-cookie");
const http = require("http");
const vm = require("vm");
const concat = require("concat-stream");
const MockXMLHttpRequest = __importStar(require("mock-xmlhttprequest"));
const { JSDOM } = jsdom;
const baseFile = "/m4jsapi_node/m4jsapi_node.nocache.js";
class M4ApiNode {
    /**
     * Constructor
     * @param {string} server
     * @param {string} user
     * @param {string} pass
     */
    constructor(server, user, pass) {
        this.server = server;
        this.user = user;
        this.pass = pass;
        this.apiUrl = server + baseFile;
        this.m4Store = new tough.MemoryCookieStore();
        this.m4CookieStore = new tough.CookieJar(this.m4Store);
        this.showConsoleMsg = false;
        this.isMocking = false;
        this.mapMockM4ObjectMetadata = new Map();
    }
    /**
     * Returns User property value setted in constructor.
     */
    getUser() {
        return this.user;
    }
    /**
     * Returns Server property value setted in constructor.
     */
    getServer() {
        return this.server;
    }
    /**
     * Returns Api URL. (M4JSAPI Node URL)
     */
    getApiUrl() {
        return this.apiUrl;
    }
    /**
     * Returns Cookie Storage. (https://www.npmjs.com/package/tough-cookie)
     */
    getCookieStore() {
        return this.m4Store;
    }
    /**
     * Enable Console messages.
     */
    enableConsoleMessages() {
        this.showConsoleMsg = true;
    }
    /**
     * Disable Console messages.
     */
    disableConsoleMessages() {
        this.showConsoleMsg = false;
    }
    /**
     * Import JavaScript file: compile and run code
     * @param {string} url
     */
    __importJavaScriptFileFromUrl__(url) {
        this.consoleMessage("Loading Javascript file from url: " + url);
        return new Promise((resolve) => {
            http.get(url, (res) => {
                res.setEncoding('utf8');
                res.pipe(concat({ encoding: 'string' }, (remoteSrc) => {
                    const randomNameFile = Math.random().toString(36).substring(7);
                    vm.runInThisContext(remoteSrc, 'remote_modules/' + randomNameFile + ".js");
                    resolve(true);
                }));
            });
        });
    }
    /**
     * Initialize M4JSAPI Mock
     * - Override M4Executor.LoadMetadata: Load XML Metadata from mock
     */
    __mock__initialize__() {
        if (this.isMocking) {
            return;
        }
        const _metadataValues = this.mapMockM4ObjectMetadata;
        const _mockXhr = MockXMLHttpRequest.newMockXhr();
        _mockXhr.onSend = (xhr) => {
            let _responseStatus = 0;
            let _responseHeaders = null;
            let _responseData = null;
            try {
                const _urlLoadMetadata = this.server + "/servlet/M4JSServices/metadata/";
                if (!xhr.url || typeof xhr.url !== 'string') {
                    throw new Error("[M4Node.js] - Invalid URL in reponse");
                }
                if (!xhr.url.startsWith(_urlLoadMetadata)) {
                    throw new Error("[M4Node.js] - Mock not supported yet! Mock me: " + xhr.url);
                }
                const _xhrUrl = xhr.url;
                const _urlLoadMetadataV = "v/";
                const _urlLoadMetadataMd = "md/";
                if (_xhrUrl.includes(_urlLoadMetadataV)) {
                    _responseStatus = 200;
                    _responseHeaders = { 'Content-Type': 'text/plain' };
                    _responseData = "";
                }
                else if (_xhrUrl.includes(_urlLoadMetadataMd)) {
                    const idM4Object = _xhrUrl.substring((_xhrUrl.lastIndexOf(_urlLoadMetadataMd) + 3), _xhrUrl.length);
                    const idM4ObjectTrim = idM4Object.replace("/", "");
                    if (_metadataValues.has(idM4ObjectTrim) === false) {
                        throw new Error("[M4Node.js] - M4Object '" + idM4ObjectTrim + "' metadata mock must be setted");
                    }
                    _responseStatus = 200;
                    _responseHeaders = { 'Content-Type': 'text/xml' };
                    _responseData = _metadataValues.get(idM4ObjectTrim);
                }
                else {
                    throw new Error("[M4Node.js] - Mock not supported yet! Mock me: " + xhr.url);
                }
            }
            catch (error) {
                console.error(error.message);
                _responseStatus = 404;
                _responseHeaders = { 'Content-Type': 'text/plain' };
                _responseData = error.message;
            }
            xhr.respond(_responseStatus, _responseHeaders, _responseData);
        };
        this.m4WindowXHR = this.m4Window.XMLHttpRequest;
        this.m4Window.XMLHttpRequest = _mockXhr;
        this.isMocking = true;
    }
    /**
     * Reset Mock
     * - Clear M4Object XML Metadata mocked
     */
    __mock__reset__() {
        this.mapMockM4ObjectMetadata.clear();
    }
    /**
     * Finalize M4JSAPI Mock
     * - Restores M4Executor.LoadMetadata
     */
    __mock__finalize__() {
        if (!this.isMocking) {
            return;
        }
        this.m4Window.XMLHttpRequest = this.m4WindowXHR;
        this.isMocking = false;
    }
    /**
     * Set M4Object Metadata Content to mocking M4Executor.LoadMetadata
     * @param {string} m4objectId
     * @param {string} m4ObjectMetadata
     */
    __mock__setM4ObjectMetadata__(m4objectId, m4ObjectMetadata) {
        this.mapMockM4ObjectMetadata.set(m4objectId, m4ObjectMetadata);
    }
    /**
     * Get Window Object from this instance
     */
    __getWindowObject__() {
        return this.m4Window;
    }
    /**
     * Print menssage in the console.
     * @param {String} message
     */
    consoleMessage(message) {
        if (this.showConsoleMsg) {
            console.log("[M4Node.js] - " + message);
        }
    }
    /**
     * Get M4Executor.
     * @returns {M4Executor} m4Executor
     */
    getM4Executor() {
        global.window = null;
        if (!this.m4Executor) {
            this.createM4Executor();
        }
        return this.m4Executor;
    }
    /**
     * Import M4JSAPI from apiUrl property.
     */
    importM4Jsapi() {
        this.consoleMessage("Loading M4JSAPI from url: " + this.apiUrl);
        const apiUrl = this.apiUrl;
        return new Promise((resolve) => {
            http.get(apiUrl, (res) => {
                res.setEncoding('utf8');
                res.pipe(concat({ encoding: 'string' }, (remoteSrc) => {
                    vm.runInThisContext(remoteSrc, 'remote_modules/m4jsapi_node.js');
                    resolve(true);
                }));
            });
        });
    }
    /**
     * Set M4Executor.
     * @param {com.meta4.js.client.M4Executor} m4Executor
     */
    setM4Executor(m4Executor) {
        this.m4Executor = m4Executor;
    }
    /**
     * Resolves when M4JSAPI library is loaded.
     * @returns {Promise}
     */
    isM4JsapiLoaded() {
        return new Promise((resolve) => {
            window.meta4OnLoad = function meta4OnLoad() {
                resolve(true);
            };
        });
    }
    /**
     * Return jsdom.DOMWindow from instance.
     */
    getWindow() {
        return this.m4Window;
    }
    /**
     * Create M4Executor instance.
     */
    createM4Executor() {
        const localWindow = this.getWindow();
        localWindow.meta4.M4Executor.setServiceBaseUrl(this.server);
        this.setM4Executor(new localWindow.meta4.M4Executor());
    }
    /**
     * Initialize M4jsapi instance as jsdom.DOMWindow.
     */
    initializeAsync() {
        return __awaiter(this, void 0, void 0, function* () {
            const { window } = new JSDOM(``, {
                url: this.apiUrl,
                referrer: this.server,
                contentType: "text/html",
                includeNodeLocations: true,
                storageQuota: 10000000,
                cookieJar: this.m4CookieStore
            });
            this.m4Window = window;
            global.window = this.m4Window;
            global.document = this.m4Window.document;
            global.navigator = this.m4Window.navigator;
            global.DOMParser = this.m4Window.DOMParser;
            yield this.importM4Jsapi();
            const bIsM4JsapiLoaded = yield this.isM4JsapiLoaded();
            return bIsM4JsapiLoaded;
        });
    }
    /**
     * Logon User promise-based asynchronous.
     */
    logon() {
        const _m4Executor = this.getM4Executor();
        const _user = this.user;
        const _pass = this.pass;
        this.consoleMessage("User Logon '" + _user + "'");
        return new Promise((resolve, reject) => {
            _m4Executor.logon(_user, _pass, "2", (request) => {
                if (!request.getResult()) {
                    reject(request);
                }
                else {
                    resolve(request.getResult());
                }
            }, (request) => {
                reject(request);
            });
        });
    }
    /**
     * Logout User promise-based asynchronous.
     */
    logout() {
        const _m4Executor = this.getM4Executor();
        this.consoleMessage("User logout '" + this.user + "'");
        return new Promise((resolve) => {
            _m4Executor.logout((request) => {
                resolve(request);
            }, (request) => {
                resolve(request);
            });
        });
    }
    /**
     * Load Metadata promise-based asynchronous.
     * @param {Array} m4ObjectIds M4Object Ids to load metadata.
     */
    loadMetadata(m4ObjectIds) {
        this.consoleMessage("Loading the metadata objects: " + m4ObjectIds.toString());
        const _m4Executor = this.getM4Executor();
        return new Promise((resolve, reject) => {
            _m4Executor.loadMetadata(m4ObjectIds, (request) => {
                resolve(request);
            }, (request) => {
                reject(request);
            });
        });
    }
    ;
    /**
     * Execute method promise-based asynchronous. [Implicitly load metadata]
     * @param {String} m4objectId M4Object ID
     * @param {String} nodeId Node ID
     * @param {String} methodId Method ID
     * @param {Array} methodArgs Method arguments
     */
    executeMethod(m4objectId, nodeId, methodId, methodArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            this.consoleMessage("Execute method - Detail > M4O: '" + m4objectId + "' > Node: '" + nodeId + "' > Method: '" + methodId + "'");
            const m4object = yield this.createM4Object(m4objectId);
            const executeMethod = yield this.executeM4ObjectMethod(m4object, nodeId, methodId, methodArgs);
            return executeMethod;
        });
    }
    ;
    /**
     * Execute method promise-based asynchronous.
     * @param {String} m4objectId M4Object ID
     * @param {String} nodeId Node ID
     * @param {String} methodId Method ID
     * @param {Array} methodArgs Method arguments
     */
    executeM4ObjectMethod(m4object, nodeId, methodId, methodArgs) {
        const _m4Executor = this.getM4Executor();
        const _localWindow = this.getWindow();
        this.consoleMessage("Execute M4Object method - Detail > M4O: '" + m4object.getId() + "' > Node: '" + nodeId + "' > Method: '" + methodId + "'");
        return new Promise((resolve, reject) => {
            const _request = new _localWindow.meta4.M4Request(m4object, nodeId, methodId, methodArgs);
            _m4Executor.execute(_request, (request) => {
                resolve(request);
            }, (request) => {
                reject(request);
            });
        });
    }
    ;
    /**
     * Execute MRequest instance.
     * @param {M4Request} m4Request
     */
    executeM4Request(m4Request) {
        const _m4Executor = this.getM4Executor();
        this.consoleMessage("Execute M4Request - Detail > M4O: '" + m4Request.getObjectId() + "' > Node: '" + m4Request.getNodeId() + "' > Method: '" + m4Request.getMethodId() + "'");
        return new Promise((resolve, reject) => {
            _m4Executor.execute(m4Request, (request) => {
                resolve(request);
            }, (request) => {
                reject(request);
            });
        });
    }
    ;
    /**
     * Execute method promise-based asynchronous.
     * @param {M4Object} m4object M4Object instance
     * @param {String} nodeId Node ID
     * @param {String} methodId Method ID
     * @param {Array} methodArgs Method arguments
     */
    createM4Request(m4object, nodeId, methodId, methodArgs) {
        const _localWindow = this.getWindow();
        const _request = new _localWindow.meta4.M4Request(m4object, nodeId, methodId, methodArgs);
        return _request;
    }
    ;
    /**
     * Convert execute method Promise to Observable RxJS. [Implicitly load metadata]
     * @param {String} m4objectId M4Object ID
     * @param {String} nodeId Node ID
     * @param {String} methodId Method ID
     * @param {Array} methodArgs Method arguments
     */
    executeMethodObservable(m4objectId, nodeId, methodId, methodArgs) {
        const _executeMethodObservable = rxjs.from(this.executeMethod(m4objectId, nodeId, methodId, methodArgs));
        return _executeMethodObservable;
    }
    /**
     * Create object instance asynchronous. [Implicitly load metadata]
     * @param {String} m4objectId M4Object ID
     */
    createM4Object(m4objectId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.loadMetadata([m4objectId]);
            const _localWindow = this.getWindow();
            return new _localWindow.meta4.M4Object(m4objectId);
        });
    }
    /**
     * Register node item changed callback as RxJS Observable.
     * @param {M4Node} m4Node M4Node
     */
    createObservableByNodeItemChanged(m4Node) {
        const _localWindow = this.getWindow();
        const observable = new rxjs.Observable(subscriber => {
            function subscriberFunction(eventValue) {
                subscriber.next(eventValue);
                subscriber.complete();
            }
            m4Node.register(_localWindow.meta4.M4EventTypes.getItemChanged(), subscriberFunction.bind(this), null);
        });
        return observable;
    }
    /**
     * Register node records changed callback as RxJS Observable.
     * @param {M4Node} m4Node M4Node
     */
    createObservableByNodeRecordsChanged(m4Node) {
        const _localWindow = this.getWindow();
        const observable = new rxjs.Observable(subscriber => {
            function subscriberFunction(eventValue) {
                subscriber.next(eventValue);
                subscriber.complete();
            }
            m4Node.register(_localWindow.meta4.M4EventTypes.getNodeRecordsChanged(), subscriberFunction.bind(this), null);
        });
        return observable;
    }
    /**
     * Register node current changed callback as RxJS Observable.
     * @param {M4Node} m4Node M4Node
     */
    createObservableByNodeCurrentChanged(m4Node) {
        const _localWindow = this.getWindow();
        const observable = new rxjs.Observable(subscriber => {
            function subscriberFunction(eventValue) {
                subscriber.next(eventValue);
                subscriber.complete();
            }
            m4Node.register(_localWindow.meta4.M4EventTypes.getNodeCurrentChanged(), subscriberFunction.bind(this), null);
        });
        return observable;
    }
}
exports.M4ApiNode = M4ApiNode;
//# sourceMappingURL=m4apiNode.js.map