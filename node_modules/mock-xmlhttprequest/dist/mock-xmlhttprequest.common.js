/**
 * mock-xmlhttprequest v5.1.0
 * (c) 2019 Bertrand Guay-Paquet
 * @license ISC
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/**
 * XMLHttpRequest events
 */
var Event = function Event(type, loaded, total) {
  this.type = type;
  this.loaded = loaded !== undefined ? loaded : 0;
  if (total > 0) {
    this.total = total;
    this.lengthComputable = true;
  } else {
    this.total = 0;
    this.lengthComputable = false;
  }
};

function flattenUseCaptureFlag(options) {
  if (typeof options === 'boolean') {
    return options;
  }
  return !!options.capture;
}

/**
 * An EventTarget object represents a target to which an event can be dispatched when something has
 * occurred.
 *
 * Based on https://dom.spec.whatwg.org/#interface-eventtarget
 */
var EventTarget = function EventTarget(eventContext) {
  if ( eventContext === void 0 ) eventContext = this;

  this._eventContext = eventContext;
  this._eventListeners = {};
};

/**
 * @returns {boolean} whether any event listener is registered
 */
EventTarget.prototype.hasListeners = function hasListeners () {
    var this$1 = this;

  return EventTarget.events.some(function (event) {
    return this$1._eventListeners[event] || this$1[("on" + event)];
  });
};

/**
 * Add an event listener.
 * See https://dom.spec.whatwg.org/#dom-eventtarget-addeventlistener
 *
 * @param {string} type event type ('load', 'abort', etc)
 * @param {EventListener|Function} callback listener callback
 * @param {boolean|object} options options object or the useCapture flag
 */
EventTarget.prototype.addEventListener = function addEventListener (type, callback, options) {
    if ( options === void 0 ) options = false;

  if (callback) {
    var useCapture = flattenUseCaptureFlag(options);
    var listener = {
      callback: callback,
      useCapture: useCapture,
      once: !!options.once,
    };

    this._eventListeners[type] = this._eventListeners[type] || [];

    // If eventTarget’s event listener list does not contain an event listener whose type is
    // listener’s type, callback is listener’s callback, and capture is listener’s capture, then
    // append listener to eventTarget’s event listener list.
    // See https://dom.spec.whatwg.org/#add-an-event-listener
    if (!this._eventListeners[type].some(function (other) {
      return other.callback === listener.callback && other.useCapture === listener.useCapture;
    })) {
      this._eventListeners[type].push(listener);
    }
  }
};

/**
 * Remove an event listener.
 * See https://dom.spec.whatwg.org/#dom-eventtarget-removeeventlistener
 *
 * @param {string} type event type ('load', 'abort', etc)
 * @param {EventListener|Function} callback listener callback
 * @param {boolean|object} options options object or the useCapture flag
 */
EventTarget.prototype.removeEventListener = function removeEventListener (type, callback, options) {
    if ( options === void 0 ) options = false;

  if (this._eventListeners[type]) {
    var useCapture = flattenUseCaptureFlag(options);
    var index = this._eventListeners[type].findIndex(function (listener) {
      return callback === listener.callback && useCapture === listener.useCapture;
    });
    if (index >= 0) {
      this._eventListeners[type].splice(index, 1);
    }
  }
};

/**
 * Calls all the listeners for the event.
 *
 * @param {object} event event
 * @returns {boolean} always true since none of the xhr event are cancelable
 */
EventTarget.prototype.dispatchEvent = function dispatchEvent (event) {
    var this$1 = this;

  // Only the event listeners registered at this point should be called. Storing them here avoids
  // problems with callbacks that add or remove listeners.
  var listeners = [];
  if (this._eventListeners[event.type]) {
    listeners.push.apply(listeners, this._eventListeners[event.type].map(function (listener) { return listener.callback; }));

    // Remove 'once' listeners
    this._eventListeners[event.type] = this._eventListeners[event.type]
      .filter(function (listener) { return !listener.once; });
  }

  // Handle event listeners added as object properties (e.g. obj.onload = ...)
  if (EventTarget.events.includes(event.type)) {
    var listener = this[("on" + (event.type))];
    if (listener) {
      listeners.push(listener);
    }
  }

  // Call the listeners
  listeners.forEach(function (listener) {
    if (typeof listener === 'function') {
      listener.call(this$1._eventContext, event);
    } else {
      listener.handleEvent();
    }
  });
  return true;
};

/**
 * XMLHttpRequest events
 */
EventTarget.events = [
  'loadstart',
  'progress',
  'abort',
  'error',
  'load',
  'timeout',
  'loadend' ];

/**
 * HTTP header container
 */
var HeadersContainer = function HeadersContainer(headers) {
  var this$1 = this;

  this._headers = new Map();
  if (headers && headers instanceof Object) {
    Object.keys(headers).forEach(function (key) {
      this$1.addHeader(key, headers[key]);
    });
  }
};

/**
 * Reset the container to its empty state.
 */
HeadersContainer.prototype.reset = function reset () {
  this._headers.clear();
};

/**
 * Get header value. Header names are case-insensitive.
 *
 * @param{string} name header name
 * @returns {string|null} header value or null
 */
HeadersContainer.prototype.getHeader = function getHeader (name) {
  var value = this._headers.get(name.toLowerCase());
  return value !== undefined ? value : null;
};

/**
 * Get all headers as a string. Each header is on its own line.
 *
 * @returns {string} concatenated headers
 */
HeadersContainer.prototype.getAll = function getAll () {
    var this$1 = this;

  // Sort the header names. It's not mandated by RFC 7230 but it makes assertion testing easier
  // and, most importantly, it is required by getAllResponseHeaders() of XMLHttpRequest.
  // See https://xhr.spec.whatwg.org/#the-getallresponseheaders()-method
  var headerNames = [].concat( this._headers.keys() ).sort();

  // Combine the header values
  var headers = headerNames.reduce(function (result, name) {
    var headerValue = this$1._headers.get(name);
    return ("" + result + name + ": " + headerValue + "\r\n");
  }, '');
  return headers;
};

/**
 * Get all headers as an object.
 *
 * @returns {object} headers
 */
HeadersContainer.prototype.getHash = function getHash () {
  var headers = {};
  this._headers.forEach(function (value, name) {
    headers[name] = value;
  });
  return headers;
};

/**
 * Add a header value, combining it with any previous value for the same header name.
 *
 * @param {string} name header name
 * @param {string} value header value
 */
HeadersContainer.prototype.addHeader = function addHeader (name, value) {
  name = name.toLowerCase();
  var currentValue = this._headers.get(name);
  if (currentValue) {
    value = currentValue + ", " + value;
  }
  this._headers.set(name, value);
};

// Disallowed request headers for setRequestHeader()
var forbiddenHeaders = [
  'Accept-Charset',
  'Accept-Encoding',
  'Access-Control-Request-Headers',
  'Access-Control-Request-Method',
  'Connection',
  'Content-Length',
  'Cookie',
  'Cookie2',
  'Date',
  'DNT',
  'Expect',
  'Host',
  'Keep-Alive',
  'Origin',
  'Referer',
  'TE',
  'Trailer',
  'Transfer-Encoding',
  'Upgrade',
  'Via' ];
var forbiddenHeaderRegEx = new RegExp(("^(" + (forbiddenHeaders.join('|')) + "|Proxy-.*|Sec-.*)$"), 'i');

/**
 * See https://fetch.spec.whatwg.org/#forbidden-header-name
 *
 * @param {string} name header name
 * @returns {boolean} whether the request header name is forbidden for XMLHttpRequest
 */
function isRequestHeaderForbidden(name) {
  return forbiddenHeaderRegEx.test(name);
}

/**
 * See https://fetch.spec.whatwg.org/#forbidden-method
 *
 * @param {string} name method name
 * @returns {boolean} whether the request method is forbidden for XMLHttpRequest
 */
function isRequestMethodForbidden(method) {
  return /^(CONNECT|TRACE|TRACK)$/i.test(method);
}

// Normalize method names as described in open()
// https://xhr.spec.whatwg.org/#the-open()-method
var upperCaseMethods = [
  'DELETE',
  'GET',
  'HEAD',
  'OPTIONS',
  'POST',
  'PUT' ];
var upperCaseMethodsRegEx = new RegExp(("^(" + (upperCaseMethods.join('|')) + ")$"), 'i');

/**
 * See https://fetch.spec.whatwg.org/#concept-method-normalize
 *
 * @param {string} method HTTP method name
 * @returns {string} normalized method name
 */
function normalizeHTTPMethodName(method) {
  if (upperCaseMethodsRegEx.test(method)) {
    method = method.toUpperCase();
  }
  return method;
}

// Status code reason phrases from RFC 7231 §6.1, RFC 4918, RFC 5842, RFC 6585 and RFC 7538
var statusTexts = {
  100: 'Continue',
  101: 'Switching Protocols',
  200: 'OK',
  201: 'Created',
  202: 'Accepted',
  203: 'Non-Authoritative Information',
  204: 'No Content',
  205: 'Reset Content',
  206: 'Partial Content', // RFC 7233
  207: 'Multi-Status', // RFC 4918
  208: 'Already Reported', // RFC 5842
  300: 'Multiple Choices',
  301: 'Moved Permanently',
  302: 'Found',
  303: 'See Other',
  304: 'Not Modified', // RFC 7232
  305: 'Use Proxy',
  307: 'Temporary Redirect',
  308: 'Permanent Redirect', // RFC 7538
  400: 'Bad Request',
  401: 'Unauthorized', // RFC 7235
  402: 'Payment Required',
  403: 'Forbidden',
  404: 'Not Found',
  405: 'Method Not Allowed',
  406: 'Not Acceptable',
  407: 'Proxy Authentication Required', // RFC 7235
  408: 'Request Timeout',
  409: 'Conflict',
  410: 'Gone',
  411: 'Length Required',
  412: 'Precondition Failed', // RFC 7232
  413: 'Payload Too Large',
  414: 'URI Too Long',
  415: 'Unsupported Media Type',
  416: 'Range Not Satisfiable', // RFC 7233
  417: 'Expectation Failed',
  422: 'Unprocessable Entity', // RFC 4918
  423: 'Locked', // RFC 4918
  424: 'Failed Dependency', // RFC 4918
  426: 'Upgrade Required',
  428: 'Precondition Required', // RFC 6585
  429: 'Too Many Requests', // RFC 6585
  431: 'Request Header Fields Too Large', // RFC 6585
  500: 'Internal Server Error',
  501: 'Not Implemented',
  502: 'Bad Gateway',
  503: 'Service Unavailable',
  504: 'Gateway Timeout',
  505: 'HTTP Version Not Supported',
  507: 'Insufficient Storage', // RFC 4918
  511: 'Network Authentication Required', // RFC 6585
};

/**
 * @param {number} status HTTP status code
 * @returns {string} status text
 */
function getStatusText(status) {
  return statusTexts[status] || 'Unknown Status';
}

function throwError(type, text) {
  if ( text === void 0 ) text = '';

  var exception = new Error(text);
  exception.name = type;
  throw exception;
}

/**
 * XMLHttpRequest mock for testing.
 * Based on https://xhr.spec.whatwg.org version '28 November 2018'.
 *
 * Supports:
 *  - events and states
 *  - open(), setRequestHeader(), send() and abort()
 *  - upload and download progress events
 *  - response status, statusText, headers and body
 *  - the timeout attribute (can be disabled) (since v4.0.0)
 *  - simulating a network error
 *  - simulating a request timeout (see MockXhr.setRequestTimeout())
 *
 * Partial support:
 *  - overrideMimeType(): throws when required, but has no other effect.
 *  - responseType: '', 'text' and 'json' are fully supported. Other responseType values can also be
 *    used, but they will return the response body given to setResponseBody() as-is in xhr.response.
 *  - responseXml: the response body is not converted to a document response. To get a document
 *    response, use it directly as the response body in setResponseBody().
 *
 * Not supported:
 * - synchronous requests (i.e. async == false)
 * - parsing the url and setting the username and password since there are no actual HTTP requests
 * - responseUrl (i.e. the final request url with redirects) is not automatically set. This can be
 *   emulated in a request handler.
 */
var MockXhr = /*@__PURE__*/(function (EventTarget) {
  function MockXhr() {
    EventTarget.call(this);
    this._readyState = MockXhr.UNSENT;
    this.requestHeaders = new HeadersContainer();
    this._withCredentials = false;
    this._timeout = 0;
    this._upload = new EventTarget(this);
    this._response = this._networkErrorResponse();

    // Per-instance flag to enable the effects of the timeout attribute
    this.timeoutEnabled = true;

    // Hook for XMLHttpRequest creation
    if (typeof MockXhr.onCreate === 'function') {
      MockXhr.onCreate(this);
    }
  }

  if ( EventTarget ) MockXhr.__proto__ = EventTarget;
  MockXhr.prototype = Object.create( EventTarget && EventTarget.prototype );
  MockXhr.prototype.constructor = MockXhr;

  var prototypeAccessors = { readyState: { configurable: true },timeout: { configurable: true },withCredentials: { configurable: true },upload: { configurable: true },status: { configurable: true },statusText: { configurable: true },responseType: { configurable: true },response: { configurable: true },responseText: { configurable: true },responseXML: { configurable: true } };

  ////////////
  // States //
  ////////////

  /**
   * https://xhr.spec.whatwg.org/#dom-xmlhttprequest-readystate
   *
   * @returns {number} readystate attribute
   */
  prototypeAccessors.readyState.get = function () {
    return this._readyState;
  };

  /**
   * noop setter
   *
   * @param {*} value ignored value
   * @returns {number} value
   */
  prototypeAccessors.readyState.set = function (value) { return value; };

  /////////////
  // Request //
  /////////////

  /**
   * Set the request method and url.
   * https://xhr.spec.whatwg.org/#the-open()-method
   *
   * @param {string} method request HTTP method (GET, POST, etc.)
   * @param {string} url request url
   * @param {boolean} async async request flag (only true is supported)
   */
  MockXhr.prototype.open = function open (method, url, async) {
    if ( async === void 0 ) async = true;

    if (!async) {
      throw new Error('async = false is not supported.');
    }
    if (isRequestMethodForbidden(method)) {
      throwError('SecurityError', ("Method \"" + method + "\" forbidden."));
    }
    method = normalizeHTTPMethodName(method);
    // Skip parsing the url and setting the username and password

    this._terminateRequest();

    // Set variables
    this._sendFlag = false;
    this._uploadListenerFlag = false;
    this.method = method;
    this.url = url;
    this.requestHeaders.reset();
    this._response = this._networkErrorResponse();
    if (this._readyState !== MockXhr.OPENED) {
      this._readyState = MockXhr.OPENED;
      this._fireReadyStateChange();
    }
  };

  /**
   * Add a request header value.
   * https://xhr.spec.whatwg.org/#the-setrequestheader()-method
   *
   * @param {string} name header name
   * @param {string} value header value
   */
  MockXhr.prototype.setRequestHeader = function setRequestHeader (name, value) {
    if (this._readyState !== MockXhr.OPENED || this._sendFlag) {
      throwError('InvalidStateError');
    }
    if (typeof name !== 'string' || typeof value !== 'string') {
      throw new SyntaxError();
    }

    if (!isRequestHeaderForbidden(name)) {
      // Normalize value
      value = value.trim();
      this.requestHeaders.addHeader(name, value);
    }
  };

  /**
   * https://xhr.spec.whatwg.org/#dom-xmlhttprequest-timeout
   *
   * @returns {number} timeout attribute
   */
  prototypeAccessors.timeout.get = function () {
    return this._timeout;
  };

  /**
   * https://xhr.spec.whatwg.org/#dom-xmlhttprequest-timeout
   *
   * @param {number} value timeout value
   */
  prototypeAccessors.timeout.set = function (value) {
    // Since this library is meant to run on node, skip the step involving the Window object.
    this._timeout = value;
    if (this._sendFlag && this.timeoutEnabled && this.constructor.timeoutEnabled) {
      // A fetch is active so schedule a request timeout
      this._scheduleRequestTimeout();
    }
  };

  /**
   * https://xhr.spec.whatwg.org/#dom-xmlhttprequest-withcredentials
   *
   * @returns {boolean} withCredentials attribute
   */
  prototypeAccessors.withCredentials.get = function () {
    return this._withCredentials;
  };

  /**
   * https://xhr.spec.whatwg.org/#dom-xmlhttprequest-withcredentials
   *
   * @param {boolean} value withCredentials value
   */
  prototypeAccessors.withCredentials.set = function (value) {
    if ((this._readyState !== MockXhr.UNSENT && this._readyState !== MockXhr.OPENED)
      || this._sendFlag) {
      throwError('InvalidStateError');
    }
    this._withCredentials = !!value;
  };

  /**
   * https://xhr.spec.whatwg.org/#the-upload-attribute
   *
   * @returns {EventTarget} upload attribute
   */
  prototypeAccessors.upload.get = function () {
    return this._upload;
  };

  /**
   * noop setter
   *
   * @param {*} value ignored value
   * @returns {EventTarget} value
   */
  prototypeAccessors.upload.set = function (value) { return value; };

  /**
   * Initiate the request.
   * https://xhr.spec.whatwg.org/#the-send()-method
   *
   * @param {*} body request body
   */
  MockXhr.prototype.send = function send (body) {
    var this$1 = this;
    if ( body === void 0 ) body = null;

    if (this._readyState !== MockXhr.OPENED || this._sendFlag) {
      throwError('InvalidStateError');
    }
    if (this.method === 'GET' || this.method === 'HEAD') {
      body = null;
    }

    if (body !== null) {
      var extractedContentType = null;

      // Document body type not supported

      // https://fetch.spec.whatwg.org/#concept-bodyinit-extract
      {
        var contentType = null;
        if (typeof body === 'string') {
          contentType = 'text/plain;charset=UTF-8';
        } else if (body.type) {
          // As specified for Blob
          contentType = body.type;
        }

        // BufferSource, FormData, etc. not handled specially
        extractedContentType = contentType;
      }

      /*
      * Skipping step "4. If author request headers contains `Content-Type`, then:"
      * Parsing mime type strings and overriding the charset to UTF-8 seems like a lot of work
      * for little gain. If I'm wrong, please open an issue or better yet a pull request.
      */

      if (this.requestHeaders.getHeader('Content-Type') === null && extractedContentType !== null) {
        this.requestHeaders.addHeader('Content-Type', extractedContentType);
      }
    }

    this._uploadListenerFlag = this._upload.hasListeners();
    this.body = body;
    this._uploadCompleteFlag = this.body === null;
    this._timedOutFlag = false;
    this._sendFlag = true;

    this._fireEvent('loadstart', 0, 0);
    if (!this._uploadCompleteFlag && this._uploadListenerFlag) {
      this._fireUploadEvent('loadstart', 0, this._getRequestBodySize());
    }

    // Other interactions are done through the mock's response methods
    if (this._readyState !== MockXhr.OPENED || !this._sendFlag) {
      return;
    }

    this._timeoutReference = Date.now();
    this._scheduleRequestTimeout();

    // Hook for XMLHttpRequest.send(). Execute in an empty callstack
    if (typeof this.onSend === 'function') {
      // Save the callback in case it changes before it has a chance to run
      var ref = this;
      var onSend = ref.onSend;
      setTimeout(function () { return onSend.call(this$1, this$1); }, 0);
    }
    if (typeof MockXhr.onSend === 'function') {
      // Save the callback in case it changes before it has a chance to run
      var onSend$1 = MockXhr.onSend;
      setTimeout(function () { return onSend$1.call(this$1, this$1); }, 0);
    }
  };

  /**
   * Abort the request.
   * https://xhr.spec.whatwg.org/#the-abort()-method
   */
  MockXhr.prototype.abort = function abort () {
    this._terminateRequest();

    if ((this._readyState === MockXhr.OPENED && this._sendFlag)
      || this._readyState === MockXhr.HEADERS_RECEIVED
      || this._readyState === MockXhr.LOADING) {
      this._requestErrorSteps('abort');
    }

    if (this._readyState === MockXhr.DONE) {
      // No readystatechange event is dispatched.
      this._readyState = MockXhr.UNSENT;
      this._response = this._networkErrorResponse();
    }
  };

  //////////////
  // Response //
  //////////////

  /**
   * https://xhr.spec.whatwg.org/#dom-xmlhttprequest-status
   *
   * @returns {number} status attribute
   */
  prototypeAccessors.status.get = function () {
    return this._response.status;
  };

  /**
   * noop setter
   *
   * @param {*} value ignored value
   * @returns {number} value
   */
  prototypeAccessors.status.set = function (value) { return value; };

  /**
   * https://xhr.spec.whatwg.org/#the-statustext-attribute
   *
   * @returns {string} statusText attribute
   */
  prototypeAccessors.statusText.get = function () {
    return this._response.statusMessage;
  };

  /**
   * noop setter
   *
   * @param {*} value ignored value
   * @returns {string} value
   */
  prototypeAccessors.statusText.set = function (value) { return value; };

  /**
   * Get a response header value.
   * https://xhr.spec.whatwg.org/#dom-xmlhttprequest-getresponseheader
   *
   * @param {string} name header name
   * @returns {string} header value
   */
  MockXhr.prototype.getResponseHeader = function getResponseHeader (name) {
    return this._response.headers.getHeader(name);
  };

  /**
   * Get all response headers as a string.
   * https://xhr.spec.whatwg.org/#dom-xmlhttprequest-getallresponseheaders
   *
   * @returns {string} concatenated headers
   */
  MockXhr.prototype.getAllResponseHeaders = function getAllResponseHeaders () {
    return this._response.headers.getAll();
  };

  /**
   * https://xhr.spec.whatwg.org/#dom-xmlhttprequest-overridemimetype
   *
   * @param {string} mime MIME type
   */
  MockXhr.prototype.overrideMimeType = function overrideMimeType (/* mime */) {
    if (this._readyState === MockXhr.LOADING || this._readyState === MockXhr.DONE) {
      throwError('InvalidStateError');
    }
    // noop
  };

  /**
   * https://xhr.spec.whatwg.org/#dom-xmlhttprequest-responsetype
   *
   * @returns {string} responseType attribute
   */
  prototypeAccessors.responseType.get = function () {
    return this._responseType || '';
  };

  /**
   * https://xhr.spec.whatwg.org/#dom-xmlhttprequest-responsetype
   *
   * @param {string} value responseType value
   */
  prototypeAccessors.responseType.set = function (value) {
    // Since this library is meant to run on node, skip the steps involving the Window object.
    if (this._readyState === MockXhr.LOADING || this._readyState === MockXhr.DONE) {
      throwError('InvalidStateError');
    }

    // The spec doesn't mandate throwing anything on invalid values since values must be of type
    // XMLHttpRequestResponseType. Observed browser behavior is to ignore invalid values.
    var responseTypes = ['', 'arraybuffer', 'blob', 'document', 'json', 'text'];
    if (responseTypes.includes(value)) {
      this._responseType = value;
    }
  };

  /**
   * https://xhr.spec.whatwg.org/#the-response-attribute
   *
   * @returns {*} response
   */
  prototypeAccessors.response.get = function () {
    if (this.responseType === '' || this.responseType === 'text') {
      if (this._readyState !== MockXhr.LOADING && this._readyState !== MockXhr.DONE) {
        return '';
      }

      // No support for charset decoding as outlined in https://xhr.spec.whatwg.org/#text-response
      return this._response.body === null ? '' : this._response.body;
    }

    if (this._readyState !== MockXhr.DONE) {
      return null;
    }

    if (this.responseType === 'json') {
      if (this._response.body === null) {
        return null;
      }
      try {
        return JSON.parse(this._response.body);
      } catch (e) {
        return null;
      }
    }

    // Other responseTypes are sent as-is. They can be given directly by setResponseBody() anyway.
    return this._response.body;
  };

  /**
   * noop setter
   *
   * @param {*} value ignored value
   * @returns {*} value
   */
  prototypeAccessors.response.set = function (value) { return value; };

  /**
   * https://xhr.spec.whatwg.org/#the-responsetext-attribute
   *
   * @returns {string} responseText attribute
   */
  prototypeAccessors.responseText.get = function () {
    if (this.responseType !== '' && this.responseType !== 'text') {
      throwError('InvalidStateError');
    }
    if (this._readyState !== MockXhr.LOADING && this._readyState !== MockXhr.DONE) {
      return '';
    }

    // No support for charset decoding as outlined in https://xhr.spec.whatwg.org/#text-response
    return this._response.body === null ? '' : this._response.body;
  };

  /**
   * noop setter
   *
   * @param {*} value ignored value
   * @returns {string} value
   */
  prototypeAccessors.responseText.set = function (value) { return value; };

  /**
   * https://xhr.spec.whatwg.org/#dom-xmlhttprequest-responsexml
   *
   * @returns {*} responseXML attribute
   */
  prototypeAccessors.responseXML.get = function () {
    if (this.responseType !== '' && this.responseType !== 'document') {
      throwError('InvalidStateError');
    }
    if (this._readyState !== MockXhr.DONE) {
      return null;
    }

    // Since this library is meant to run on node, there is no support for charset decoding as
    // outlined in https://xhr.spec.whatwg.org/#text-response
    // If needed, a document response can be given to setResponseBody() to be returned here.
    return this._response.body === null ? '' : this._response.body;
  };

  /**
   * noop setter
   *
   * @param {*} value ignored value
   * @returns {*} value
   */
  prototypeAccessors.responseXML.set = function (value) { return value; };

  ///////////////////////////
  // Mock response methods //
  ///////////////////////////

  /**
   * Fire a request upload progress event.
   *
   * @param {number} transmitted bytes transmitted
   */
  MockXhr.prototype.uploadProgress = function uploadProgress (transmitted) {
    if (!this._sendFlag || this._uploadCompleteFlag) {
      throw new Error('Mock usage error detected.');
    }
    if (this._uploadListenerFlag) {
      // If no listeners were registered before send(), no upload events should be fired.
      this._fireUploadEvent('progress', transmitted, this._getRequestBodySize());
    }
  };

  /**
   * Complete response method. Sets the response headers and body. Will set the
   * state to DONE.
   *
   * @param {?number} status response http status (default 200)
   * @param {?object} headers name-value headers (optional)
   * @param {?*} body response body (default null)
   * @param {?string} statusText response http status text (optional)
   */
  MockXhr.prototype.respond = function respond (status, headers, body, statusText) {
    this.setResponseHeaders(status, headers, statusText);
    this.setResponseBody(body);
  };

  /**
   * Set only the response headers. Will change the state to HEADERS_RECEIVED.
   *
   * @param {?number} status response http status (default 200)
   * @param {?object} headers name-value headers (optional)
   * @param {?string} statusText response http status text (optional)
   */
  MockXhr.prototype.setResponseHeaders = function setResponseHeaders (status, headers, statusText) {
    if (this._readyState !== MockXhr.OPENED || !this._sendFlag) {
      throw new Error('Mock usage error detected.');
    }
    if (this.body) {
      this._requestEndOfBody();
    }
    status = typeof status === 'number' ? status : 200;
    var statusMessage = statusText !== undefined ? statusText : getStatusText(status);
    this._processResponse({
      status: status,
      statusMessage: statusMessage,
      headers: new HeadersContainer(headers),
    });
  };

  /**
   * Fire a response progress event. Will set the state to LOADING.
   *
   * @param {number} transmitted transmitted bytes
   * @param {number} length total bytes
   */
  MockXhr.prototype.downloadProgress = function downloadProgress (transmitted, length) {
    if (this._readyState !== MockXhr.HEADERS_RECEIVED
      && this._readyState !== MockXhr.LOADING) {
      throw new Error('Mock usage error detected.');
    }

    // Useless condition but follows the spec's wording
    if (this._readyState === MockXhr.HEADERS_RECEIVED) {
      this._readyState = MockXhr.LOADING;
    }

    // As stated in https://xhr.spec.whatwg.org/#the-send()-method
    // Web compatibility is the reason readystatechange fires more often than
    // state changes.
    this._fireReadyStateChange();
    this._fireEvent('progress', transmitted, length);
  };

  /**
   * Set the response body. Will set the state to DONE.
   *
   * @param {?*} body response body (default null)
   */
  MockXhr.prototype.setResponseBody = function setResponseBody (body) {
    if ( body === void 0 ) body = null;

    if (!this._sendFlag
      || (this._readyState !== MockXhr.OPENED
        && this._readyState !== MockXhr.HEADERS_RECEIVED
        && this._readyState !== MockXhr.LOADING)) {
      throw new Error('Mock usage error detected.');
    }
    if (this._readyState === MockXhr.OPENED) {
      // Default "200 - OK" response headers
      this.setResponseHeaders();
    }

    // As stated in https://xhr.spec.whatwg.org/#the-send()-method
    // Web compatibility is the reason readystatechange fires more often than
    // state changes.
    this._readyState = MockXhr.LOADING;
    this._fireReadyStateChange();

    this._response.body = body !== undefined ? body : null;
    this._handleResponseEndOfBody();
  };

  /**
   * Simulate a network error. Will set the state to DONE.
   */
  MockXhr.prototype.setNetworkError = function setNetworkError () {
    if (!this._sendFlag) {
      throw new Error('Mock usage error detected.');
    }
    this._processResponse(this._networkErrorResponse());
  };

  /**
   * Simulate a request timeout. Will set the state to DONE.
   */
  MockXhr.prototype.setRequestTimeout = function setRequestTimeout () {
    if (!this._sendFlag) {
      throw new Error('Mock usage error detected.');
    }
    this._terminateRequest();
    this._timedOutFlag = true;
    this._processResponse(this._networkErrorResponse());
  };

  ///////////////////////////////////
  // Request and response handling //
  ///////////////////////////////////

  /**
   * Note: the "process request body" task is in the MockXhr response methods
   * Process request end-of-body task. When the whole request is sent.
   * https://xhr.spec.whatwg.org/#the-send()-method
   */
  MockXhr.prototype._requestEndOfBody = function _requestEndOfBody () {
    this._uploadCompleteFlag = true;

    if (this._uploadListenerFlag) {
      // If no listeners were registered before send(), these steps do not run.
      var length = this._getRequestBodySize();
      var transmitted = length;
      this._fireUploadEvent('progress', transmitted, length);
      this._fireUploadEvent('load', transmitted, length);
      this._fireUploadEvent('loadend', transmitted, length);
    }
  };

  /**
   * Process response task. When the response headers are received.
   * https://xhr.spec.whatwg.org/#the-send()-method
   *
   * @param {*} response response
   */
  MockXhr.prototype._processResponse = function _processResponse (response) {
    this._response = response;
    this._handleResponseErrors();
    if (this._isNetworkErrorResponse()) {
      return;
    }
    this._readyState = MockXhr.HEADERS_RECEIVED;
    this._fireReadyStateChange();
    if (this._readyState !== MockXhr.HEADERS_RECEIVED) {
      return;
    }
    if (this._response.body === null) {
      this._handleResponseEndOfBody();
    }
    // Further steps are triggered by the MockXhr response methods
  };

  /**
   * Handle response end-of-body for response.
   * https://xhr.spec.whatwg.org/#handle-response-end-of-body
   */
  MockXhr.prototype._handleResponseEndOfBody = function _handleResponseEndOfBody () {
    this._handleResponseErrors();
    if (this._isNetworkErrorResponse()) {
      return;
    }
    var length = this._response.body ? this._response.body.length : 0;
    this._fireEvent('progress', length, length);
    this._readyState = MockXhr.DONE;
    this._sendFlag = false;
    this._fireReadyStateChange();
    this._fireEvent('load', length, length);
    this._fireEvent('loadend', length, length);
  };

  /**
   * Handle errors for response.
   * https://xhr.spec.whatwg.org/#handle-errors
   */
  MockXhr.prototype._handleResponseErrors = function _handleResponseErrors () {
    if (!this._sendFlag) {
      return;
    }
    if (this._timedOutFlag) {
      // Timeout
      this._requestErrorSteps('timeout');
    } else if (this._isNetworkErrorResponse()) {
      // Network error
      this._requestErrorSteps('error');
    }
  };

  /**
   * The request error steps for event 'event'.
   * https://xhr.spec.whatwg.org/#request-error-steps
   *
   * @param {string} event event name
   */
  MockXhr.prototype._requestErrorSteps = function _requestErrorSteps (event) {
    this._readyState = MockXhr.DONE;
    this._sendFlag = false;
    this._response = this._networkErrorResponse();
    this._fireReadyStateChange();
    if (!this._uploadCompleteFlag) {
      this._uploadCompleteFlag = true;

      if (this._uploadListenerFlag) {
        // If no listeners were registered before send(), no upload events should be fired.
        this._fireUploadEvent(event, 0, 0);
        this._fireUploadEvent('loadend', 0, 0);
      }
    }
    this._fireEvent(event, 0, 0);
    this._fireEvent('loadend', 0, 0);
  };

  ///////////////
  // Internals //
  ///////////////

  /**
   * @returns {object} new network error response object
   */
  MockXhr.prototype._networkErrorResponse = function _networkErrorResponse () {
    return {
      type: 'error',
      status: 0,
      statusMessage: '',
      headers: new HeadersContainer(),
      body: null,
    };
  };

  MockXhr.prototype._isNetworkErrorResponse = function _isNetworkErrorResponse () {
    return this._response.type === 'error';
  };

  MockXhr.prototype._terminateRequest = function _terminateRequest () {
    delete this.method;
    delete this.url;
  };

  MockXhr.prototype._getRequestBodySize = function _getRequestBodySize () {
    if (!this.body) {
      return 0;
    }
    return this.body.size ? this.body.size : this.body.length;
  };

  MockXhr.prototype._newEvent = function _newEvent (name, transmitted, length) {
    return new Event(name, transmitted, length);
  };

  MockXhr.prototype._fireEvent = function _fireEvent (name, transmitted, length) {
    this.dispatchEvent(this._newEvent(name, transmitted, length));
  };

  MockXhr.prototype._fireUploadEvent = function _fireUploadEvent (name, transmitted, length) {
    this._upload.dispatchEvent(this._newEvent(name, transmitted, length));
  };

  MockXhr.prototype._fireReadyStateChange = function _fireReadyStateChange () {
    var event = new Event('readystatechange');
    if (this.onreadystatechange) {
      this.onreadystatechange(event);
    }
    this.dispatchEvent(event);
  };

  MockXhr.prototype._scheduleRequestTimeout = function _scheduleRequestTimeout () {
    var this$1 = this;

    // Cancel any previous timeout task
    if (this._timeoutTask) {
      clearTimeout(this._timeoutTask);
    }

    if (this._timeout > 0) {
      // The timeout delay must be measured relative to the start of fetching
      // https://xhr.spec.whatwg.org/#the-timeout-attribute
      var delay = Math.max(0, this._timeout - (Date.now() - this._timeoutReference));
      this._timeoutTask = setTimeout(function () {
        if (this$1._sendFlag) {
          this$1.setRequestTimeout();
        }
        delete this$1._timeoutTask;
      }, delay);
    }
  };

  Object.defineProperties( MockXhr.prototype, prototypeAccessors );

  return MockXhr;
}(EventTarget));

// Global flag to enable the effects of the timeout attribute
MockXhr.timeoutEnabled = true;

/**
 * The client states
 * https://xhr.spec.whatwg.org/#states
 */
MockXhr.UNSENT = 0;
MockXhr.OPENED = 1;
MockXhr.HEADERS_RECEIVED = 2;
MockXhr.LOADING = 3;
MockXhr.DONE = 4;

/**
 * Mock server for responding to XMLHttpRequest mocks from the class MockXhr. Provides simple route
 * matching and request handlers to make test harness creation easier.
 */
var MockXhrServer = function MockXhrServer(xhrMock, routes) {
  var this$1 = this;
  if ( routes === void 0 ) routes = {};

  this.MockXhr = xhrMock;
  this._requests = [];
  this._routes = {};
  Object.keys(routes).forEach(function (method) {
    var ref = routes[method];
    var matcher = ref[0];
    var handler = ref[1];
    this$1.addHandler(method, matcher, handler);
  });
  xhrMock.onSend = function (xhr) { this$1._handleRequest(xhr); };

  // Setup a mock request factory for users
  this.xhrMock = xhrMock; // For backwards compatibility with < 4.1.0
  this.xhrFactory = function () { return new this$1.MockXhr(); };
};

/**
 * Install the server's XMLHttpRequest mock in the context. Revert with remove().
 *
 * @param {object?} context context object (e.g. global, window)
 * @returns {MockXhrServer} this
 */
MockXhrServer.prototype.install = function install (context) {
    if ( context === void 0 ) context = global;

  this._savedXMLHttpRequest = context.XMLHttpRequest;
  this._savedContext = context;
  context.XMLHttpRequest = this.MockXhr;
  return this;
};

/**
 * Remove the server as the global XMLHttpRequest mock. Reverts the actions of install(global).
 */
MockXhrServer.prototype.remove = function remove () {
  if (!this._savedContext) {
    throw new Error('remove() called without matching install(global).');
  }

  if (this._savedXMLHttpRequest !== undefined) {
    this._savedContext.XMLHttpRequest = this._savedXMLHttpRequest;
    delete this._savedXMLHttpRequest;
  } else {
    delete this._savedContext.XMLHttpRequest;
  }
  delete this._savedContext;
};

/**
 * Disable the effects of the timeout attribute on the XMLHttpRequest mock used by the server.
 */
MockXhrServer.prototype.disableTimeout = function disableTimeout () {
  this.MockXhr.timeoutEnabled = false;
};

/**
 * Enable the effects of the timeout attribute on the XMLHttpRequest mock used by the server.
 */
MockXhrServer.prototype.enableTimeout = function enableTimeout () {
  this.MockXhr.timeoutEnabled = true;
};

/**
 * Add a GET request handler.
 *
 * @param {string|RegExp|Function} matcher url matcher
 * @param {object|Function|object[]|Function[]} handler request handler
 * @returns {MockXhrServer} this
 */
MockXhrServer.prototype.get = function get (matcher, handler) {
  return this.addHandler('GET', matcher, handler);
};

/**
 * Add a POST request handler.
 *
 * @param {string|RegExp|Function} matcher url matcher
 * @param {object|Function|object[]|Function[]} handler request handler
 * @returns {MockXhrServer} this
 */
MockXhrServer.prototype.post = function post (matcher, handler) {
  return this.addHandler('POST', matcher, handler);
};

/**
 * Add a PUT request handler.
 *
 * @param {string|RegExp|Function} matcher url matcher
 * @param {object|Function|object[]|Function[]} handler request handler
 * @returns {MockXhrServer} this
 */
MockXhrServer.prototype.put = function put (matcher, handler) {
  return this.addHandler('PUT', matcher, handler);
};

/**
 * Add a DELETE request handler.
 *
 * @param {string|RegExp|Function} matcher url matcher
 * @param {object|Function|object[]|Function[]} handler request handler
 * @returns {MockXhrServer} this
 */
MockXhrServer.prototype.delete = function delete$1 (matcher, handler) {
  return this.addHandler('DELETE', matcher, handler);
};

/**
 * Add a request handler.
 *
 * @param {string} method HTTP method
 * @param {string|RegExp|Function} matcher url matcher
 * @param {object|Function|object[]|Function[]} handler request handler
 * @returns {MockXhrServer} this
 */
MockXhrServer.prototype.addHandler = function addHandler (method, matcher, handler) {
  // Match the processing done in MockXHR for the method name
  method = normalizeHTTPMethodName(method);

  if (!this._routes[method]) {
    this._routes[method] = [];
  }
  this._routes[method].push({
    matcher: matcher,
    handler: handler,
    count: 0,
  });
  return this;
};

/**
 * Set the default request handler for requests that don't match any route.
 *
 * @param {object|Function|object[]|Function[]} handler request handler
 * @returns {MockXhrServer} this
 */
MockXhrServer.prototype.setDefaultHandler = function setDefaultHandler (handler) {
  this._defaultRoute = {
    handler: handler,
    count: 0,
  };
  return this;
};

/**
 * Return 404 responses for requests that don't match any route.
 *
 * @returns {MockXhrServer} this
 */
MockXhrServer.prototype.setDefault404 = function setDefault404 () {
  return this.setDefaultHandler({ status: 404 });
};

/**
 * @returns {object[]} list of requests received by the server. Entries: { method, url }
 */
MockXhrServer.prototype.getRequestLog = function getRequestLog () {
  return this._requests;
};

MockXhrServer.prototype._handleRequest = function _handleRequest (xhr) {
  // Record the request for easier debugging
  this._requests.push({
    method: xhr.method,
    url: xhr.url,
    headers: xhr.requestHeaders.getHash(),
    body: xhr.body,
  });

  var route = this._findFirstMatchingRoute(xhr) || this._defaultRoute;
  if (route) {
    // Routes can have arrays of handlers. Each one is used once and the last one is used if out
    // of elements.
    var handler = route.handler;
    if (Array.isArray(handler)) {
      handler = handler[Math.min(handler.length - 1, route.count)];
    }
    route.count += 1;

    if (typeof handler === 'function') {
      handler(xhr);
    } else {
      xhr.respond(handler.status, handler.headers, handler.body, handler.statusText);
    }
  }
};

MockXhrServer.prototype._findFirstMatchingRoute = function _findFirstMatchingRoute (xhr) {
  var method = normalizeHTTPMethodName(xhr.method);
  if (!this._routes[method]) {
    return undefined;
  }

  var url = xhr.url;
  return this._routes[method].find(function (route) {
    var matcher = route.matcher;
    if (typeof matcher === 'function') {
      return matcher(url);
    } else if (matcher instanceof RegExp) {
      return matcher.test(url);
    }
    return matcher === url;
  });
};

/**
 * Create a new "local" MockXhr subclass. This makes it easier to have self-contained unit tests
 * since "global" hooks can be registered directly on the subclass. These hooks don't need to then
 * be removed after tests because they are local to the new subclass.
 *
 * @returns {MockXhr} new MockXhr subclass
 */
function newMockXhr() {
  var LocalMockXhr = /*@__PURE__*/(function (MockXhr) {
    function LocalMockXhr() {
      MockXhr.call(this);

      // Call the local onCreate hook on the new mock instance
      if (typeof LocalMockXhr.onCreate === 'function') {
        LocalMockXhr.onCreate(this);
      }
    }

    if ( MockXhr ) LocalMockXhr.__proto__ = MockXhr;
    LocalMockXhr.prototype = Object.create( MockXhr && MockXhr.prototype );
    LocalMockXhr.prototype.constructor = LocalMockXhr;

    // Override the parent method to enable the local MockXhr instance's
    // onSend() hook
    LocalMockXhr.prototype.send = function send () {
      var this$1 = this;
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      MockXhr.prototype.send.apply(this, args);

      // Execute in an empty callstack
      if (typeof LocalMockXhr.onSend === 'function') {
        // Save the callback in case it changes before it has a chance to run
        var onSend = LocalMockXhr.onSend;
        setTimeout(function () { return onSend.call(this$1, this$1); }, 0);
      }
    };

    return LocalMockXhr;
  }(MockXhr));

  // Override the parent class' flag to enable the effects of the timeout attribute
  LocalMockXhr.timeoutEnabled = true;
  return LocalMockXhr;
}

/**
 * Create a new mock server using MockXhr.
 *
 * @returns {MockXhrServer} new mock server
 */
function newServer(routes) {
  return new MockXhrServer(newMockXhr(), routes);
}

exports.MockXhr = MockXhr;
exports.MockXhrServer = MockXhrServer;
exports.newMockXhr = newMockXhr;
exports.newServer = newServer;
